# SPM

This folder contains the exploration of using Swift Package Manager to build React Native and to generate prebuilds.

The folder contains two projects:
- **ReactNative**: this folder contains the proper SPM package that describe React Native.
- **ReactNativeApp**: this folder contains an App generated with Xcode that integrates with React Native defined by SPM.

Given that this is a POC, the SPM folder does not contains the full version of React native, but just a module with one of the most complex configurations to verify that we can build it preserving the import paths that we need.

## ReactNative folder

To use the React native project, you can double click on the `Package.swift` file. This will open Xcode and you can explore the project.

You can see that there are two folders: **ReactNative** and **ReactRenderer**.

**ReactNative** is an Objective-C++ package that imports the **ReactRenderer** using the import `react/renderer/ReactRenderer.h`.

**ReactRenderer** is a C++ package that defines a `Renderer` class and exposes a `render()` method that is empty.

From Xcode, you can build the **ReactNative** target. In turn, it will build the **ReactRenderer** target.

You can build the frameworks from the command line with the command:

```bash
xcodebuild \
  -scheme ReactNative  \
  -destination "generic/platform=iOS" \
  -derivedDataPath .build

xcodebuild \
  -scheme ReactRenderer  \
  -destination "generic/platform=iOS" \
  -derivedDataPath .build

```

This will build the project in the `.build` folder so we can inspect what has been built. In the path `.build/Build/Products/Debug-iphoneos` we can find the final product of the build. We can observe hat there are two binaries for the `.o` files that have been built. In the `PackageFrameworks` folder, we have the `ReactNative` framework binary.

> [!CAUTION]
> Observe that there are no header files there! This is a problem as it means that a user of the Framework can not import the `ReactRenderer.h` file!

### TODO:
- [x] try to expose also the React Renderer as a `.product` in Swift PM
- [x] try to build both frameworks
- [x] verify that the headers are exported in the build folder
  - The Header folder has not been created and public headers have not been moved to the artifact.
- [x] try to import the frameworks in a Xcode project to see if they works
- [x] if they works, try to define another version of package.swift that use binaries and integrate that with the project
- [x] Try build the ReactNative.framework only and to move the header there
- [X] Figure out how to generate the `_CodeSignature` folder
    - To codesign the binary, just use the command `codesign --timestamp -s "<signing identity>" ReactNative.framework`
    - We need to code sign the frameworks before we create the xcframework.
    - I integrate the sign step in the build.sh script
    - [ ] Q: signing identity: which one to use? Meta? Should we create a React Native identity?
    - [ ] Q: How do we load the identity in CI?
- [X] Try to set up distribution for binaries
- [ ] Explore how to ship Debug and Release binaries

#### 23/12/2024
I tried to define another product for the ReactNative's `Package.swift`, and I tried to create xcframeworks from them. I verified that xcodebuild does not create the Haeder folder in the `.framework` folder.

However, if we manually copy the Headers folder, it works fine, after setting the Header Search Path to `${BUILD_DIR}/${CONFIGURATION}-${PLATFORM_NAME}/ReactRenderer.framework/Headers`.
We can probably create a script that inspects the `headerFolderPath` property of the packages we define so that we can then copy them all to the final XCFrameworks.

#### 24/12/2024
I tried to build only the `ReactNative.framework` and to move the headers to that framework folder.

To automate the build process, I created the `build.sh` script that takes care of:
- building the `ReactNative.framework`.
- move the headers to the proper location.
- package the frameworks in the XCFramework file.

After obtaining the ReactNative.xcframework file, I added the binary to the `ReactNativeApp` and I tried to build and debug.
After setting the Header Search Paths to `${BUILD_DIR}/${CONFIGURATION}-${PLATFORM_NAME}/ReactNative.framework/Headers`, it worked fine and I could debug and step into the code.

> [!CAUTION]
> If we inspect the framework structure of the ones generated by the PlainXcode variant and the ones generated by SPM, there are a few relevant differences:
> 1. Xcode generates the headers automatically. While with SPM we need to handle them manually
> 2. The XCFRamework generated by Xcode has a `_CodeSignature` folder, SPM doesn't. We need to understand how to generate it with SPM
> 3. The framework generated by Xcode has a `Frameworks` folder with the dependent frameworks. The One generated by SPM does not.
> 4. Xcode needs the MERGEABLE_LIBRARIES turned on. SPM does not.
> 5. The SPM Framework is smaller than the Xcode framework.

##### Setting up binary distribution

After creating the XCFramework, is it possible to distribute it through SPM.

It's possible to distribute it together with the Sources (example in the `SPM/ReactNative/Package.swift`) or as a separate swift package (example in the `SPM/ReactNativeBinary/Package.swift`).

The separate Swift Package for the binaries still requires the `${BUILD_DIR}/${CONFIGURATION}-${PLATFORM_NAME}/ReactNative.framework/Headers` header search path, while shipping the prebuild together with the source code seems not to require it.

Building in Debug mode, the binaries are debuggable and we can step into the code easily.

**Update:**
Shipping everything in a single Swift PM breaks the build scripts and requires some changes in the build script.

Given how cheap is to ship two Package.swift files, one for the source code and one for the binaries, I'd go for the second solution.

#### 18/02/2025

I tried to add a new objc package in the mix.

The pacage is a React package that exposes an RCTBridge class.

It was easy to make it build, but then, when I added the framework to a Swift app, it failed to build because it could not build an Objective-C module.

First step to fix this, was to manually add a `Modules` folder in the frameworks. The `Modules` folder needs to contain a `module.modulemap` file that defines the modules that can be imported by Swift.

An example of a module map file is:
```
framework module ReactNative {
  umbrella header "ReactNative-umbrella.h"
  export *
  module * { export * }
}
```

The module map contains the umbrella header, the export statement and the module statement.

The umbrella header is a bridging header. It has to import all the headers that can be used by Swift.

I added the umbrella header in the Headers folder, with this content, as we only have the `RCTBridge.h` file:

```objc
#import <react/RCTBridge.h>;
```

>![WARNING]
> Note the lowercase `react`. This might be a problem as we have a `react` folder in the `ReactRenderer` package and a `React` folder in the `React` package. We need to disambiguate.

With this setup, the Swift app was able to build the Objective-C module.

The generated API for that module is now:
```swift
import ReactNative.react
import ReactNative.react.RCTBridge
```

Notice the subpath `react.RCTBridge` this namespace. I believe that we can avoid it with a smart use of the `modulemap` file, but I need to investigate it further.

The code is debuggable and inspectable from Swift.

We should be able to automatically generate the umbrella header and the modulemap file.

##### Update

We can have an empty umbrella header and specify the single header that we want in the modulemap file, like this:

```
framework module ReactNative {
  umbrella header "ReactNative-umbrella.h"
  header "react/RCTBridge.h"

  # other header files here

  export *
  module * { export * }
}
```

This will generate the following API:

```swift
import ReactNative.React
```

but it will allow the type to be used directly in the Swift side of the app:

```
import ReactNative

// ...

let bridge = RCTBridge()
bridge.loadModule("RCTAppearance")
```

The main problem here is that I believed that most of the swift code uses `import React` and not `import ReactNative`. We might have to change the name of the xcframework to `React.xcframework` not to be breaking.

From a quick search on Github, it seems that most people are using these three imports:
```swift
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
```

After we convert the ReactNative.xcframework to React.xcframework, the first import would be solved.
The `React_RCTAppDelegate` will be incorporated into React, so that line can be removed.
The `ReactAppDependencyProvider` is a module that lives in the app, so that will be generated by codegen.


## ReactNativeApp folder

The React Native App folder is an iOS app created from Xcode.

To open it, double click on the `ReactNativeApp.xcodeproj` file. The app is integrated with the ReactNative Swift Package locally.

> [!NOTE]
> You need to close the ReactNative project to properly open this app. Xcode can't handle having both the Swift Package and the Xcode project using the package open at the same time.

The app imports the `ReactRenderer` using the import `<react/renderer/ReactRenderer.h>` in the `SceneDelegate.mm`.

This app is the test bed that we can use to experiment with Swift PM.
